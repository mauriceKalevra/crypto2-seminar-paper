\documentclass[a4paper,12pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{tabto}
\usepackage{listings}

\title{Implementierung von Kryptologie in Programmiersprachen}
\subtitle{Kryptologie 2}
\author{Moritz Rupp}
\date{Wintersemester 2020}


% Mathepakete
\usepackage{amsfonts}
\usepackage{amsmath}


\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


Abstract. \newline

\dots\\
\dots\\
\dots\\

Wir werden anfangen mit 'Low level' sprachen wie Assemply und C um anschließend 'High level' Sprachen wie Java, Python und Java Script unter die Lupe zu nehmen!\\
Anschließend werden die jeweiligen Sprachen auf Ihre tauglichkeit für Kryptograhpie bewertet..\\
Kriterien wie schnelligkeit, einfachheit, sicherheit und \\
\dots\\
\\
Eines der wichtigsten Regeln in der Kryptografie besagt man solle nie seine eigene Krypto schreiben.
Das heißt dass man die Verschlüsselungsalgorithmen niemals selbst programmieren oder gar neue, für sich maßgeschneiderte Implementierungen erstellen sollte. Grund dafür ist die extrem hohe anfälligkeit die solche Versuche mit sich führen würden.
Kryptografische Verfahren haben einen langen Testprozess durchlaufen. Über viele Jahr werden sie von Experten der Prüfung un terzogen. Trotzdem gibt es immer wieder erfolgreiche Angriffe auf vermeintlich sichere Krypto.\\

\dots\\
\textbf{Was sind die Anforderungen an Programmiersprachen?}


\newpage


\section{Assembly}
Assembly sprachen stellen die tiefste Ebene der Programmiersprachen dar.
Sie laufen extrem Hardware nah und können dadurch alle Möglichkeiten eines Mikroprozessors nutzen. Dies ist zwar heutzutage meist nicht erforderlich, kann aber auf kleineren Endgeräten wie 'Iot devices' durchaus nützlich sein, weshalb gewisse Anwendungen immer noch in 'plain' Assembly code geschrieben werden.\\ Durch die Hardware nähe und die daraus resultierende schnelligkeit könnte man denken das sich Assembly code gut für Kryptografie eignet. Der Aufwand und die Komplexität ein Krypto Algorythmus in Assembly zu realisieren sind jedoch meist zu groß sodass 'High level' Sprachen beforzugt werden.\\
Ein weiterer Nachteil ist die Tatsache das Assembleysprachen sehr spezialisiert auf die jeweiligen Computerarchitekturen ausgelegt sind. Das heißt das Spezifikationen und Befehlssätze nur auf dieser bestimmten Auslegung laufen. Dies hat zur Folge das die Übertragung auf eine andere Architektur mit sehr viel Aufwand und Anpassung im Quelltext verbunden ist!\\
Des weiteren haben die wenigsten Assembleysprachen die Notwendigen Operationen bzw. Befehle die für Kryptografisches arbeiten Notwendig sind. Einfache arithmetische Operationen wie Addition oder Vergleiche von Ganzzahlen sind zwar vorhanden, komplexere Operationen wie Modulo Rechung oder Gleitkomma arithmetik nur vereinzelt und müssten sonst von Grund auf eigens definiert werden!\\
Trotz der vielen genannten Nachteile gibt es Verwendung in Bereichen in denen 'High level' Sprachen nicht genug Effizients bieten. Implementierungen in C sind zwar wesentlich einfacher zu schreiben und lesen, jedoch wäre eine Optimierte Umsetzung des gleichen Programmes in Assembly trotz moderner hoch optimierter Compiler für gewisse Aufgaben schneller.\\
Der vom C Compiler generierte Assembly code ist also potenziell schlechter bzw. ineffizienter als ein von Menschen geschriebener Assembly code!\\ Ein Grund dafür ist die Tatsache das Compiler schlecht mit großen Zahlen umgehen können. Das heißt speziell in der Kryptografie in der viel und oft mit großen Integers gearbeitet wird ist es durchaus sinnvoll gewisse Rechenoperation mit 'plain Assembly code' zu realisieren.
\newpage
Folgendes Beispiel veranschaulicht dies indem ein einfaches Programm in C anhand von GCC kompiliert wird. Anschließend wird die gleiche Operation in 'plain Assembly' nachgeschrieben. Wie sich zeigt ist der von GCC generierte Assemblycode wesentlich länger und langsamer.\\
Das C Programm realisiert das Modul addcarry u64, welches die Summe zweier 'unsigned Integers' und einem carry-in computiert und den Wert des carrys outs zurückgibt!
\vspace{7 mm}
\begin{lstlisting}
#include <stdint.h>
#include <x86intrin.h>

void add256(uint64_t a[4], uint64_t b[4]){
	uint8_t carry = 0;
	for (int i = 0; i < 4; ++i)
		carry = _addcarry_u64(carry, a[i], b[i], &a[i]);
}
\end{lstlisting}
\vspace{7 mm}
Nun der von GCC kompilierte Assemblycode:
\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    (%rdi), %rax
setc    %dl
movq    %rax, (%rdi)
movq    8(%rdi), %rax
addb    $-1, %dl
adcq    8(%rsi), %rax
setc    %dl
movq    %rax, 8(%rdi)
movq    16(%rdi), %rax
addb    $-1, %dl
adcq    16(%rsi), %rax
setc    %dl
movq    %rax, 16(%rdi)
movq    24(%rsi), %rax
addb    $-1, %dl
adcq    %rax, 24(%rdi)
ret
\end{lstlisting}
\newpage
Schreibt man das Programm nun in optimiertem Assemblycode zeigt sich das dieser wensentlich kompakter ist! \\


\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    %rax, (%rdi)
movq    8(%rsi), %rax
adcq    %rax, 8(%rdi)
movq    16(%rsi), %rax
adcq    %rax, 16(%rdi)
movq    24(%rsi), %rax
adcq    %rax, 24(%rdi)
retq
\end{lstlisting}
Auch Laufzeiten sind merklich verkürzt!\\
Je nach Kompiler und Architektur kann selbst geschriebener Assemblycode bis zu doppelt so schnell wie kompilierter Code sein!\\

\vspace{2 mm}

Stellen wir also fest das 'plain' Assemblycode durch seine schnelligkeit und Effizients für gewisse Aufgaben und Bereiche besser geeignet ist als High level Sprachen!\\
Die Frage ist nun ob das auch für Kryptografische Anwendungen gilt?!\\
Im folgenden wird das rot-13 encoding in Assembly implementiert. Dieser ist ein einfaches encoding das den \dots






\newpage
Biblotheken in Assembly
\vspace{10 mm}
\dots

Code Beispiele/Umsetzungen


\end{document}






\documentclass[a4paper,12pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{tabto}
\usepackage{listings}


\title{Implementierung von Kryptologie in Programmiersprachen}
\subtitle{Kryptologie 2}
\author{Moritz Rupp}
\date{Wintersemester 2020}


% Mathepakete
\usepackage{amsfonts}
\usepackage{amsmath}


\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


\section{Abstract}


\dots\\
\dots\\
\dots\\

Wir werden anfangen mit 'Low level' sprachen wie Assemply und C um anschließend 'High level' Sprachen wie Java, Python und Java Script unter die Lupe zu nehmen!\\
Anschließend werden die jeweiligen Sprachen auf Ihre tauglichkeit für Kryptograhpie bewertet..\\
Kriterien wie schnelligkeit, einfachheit, sicherheit und \\
\dots\\
\\
Eines der wichtigsten Regeln in der Kryptografie besagt man solle nie seine eigene Krypto schreiben.
Das heißt dass man die Verschlüsselungsalgorithmen niemals selbst programmieren oder gar neue, für sich maßgeschneiderte Implementierungen erstellen sollte. Grund dafür ist die extrem hohe anfälligkeit die solche Versuche mit sich führen würden.
Kryptografische Verfahren haben einen langen Testprozess durchlaufen. Über viele Jahr werden sie von Experten der Prüfung un terzogen. Trotzdem gibt es immer wieder erfolgreiche Angriffe auf vermeintlich sichere Krypto.\\

\dots\\
\textbf{Was sind die Anforderungen an Programmiersprachen?}


\newpage


\section{Assembly}
Assembly sprachen stellen die tiefste Ebene der Programmiersprachen dar.
Sie laufen extrem Hardware nah und können dadurch alle Möglichkeiten eines Mikroprozessors nutzen. Dies ist zwar heutzutage meist nicht erforderlich, kann aber auf kleineren Endgeräten wie 'Iot devices' durchaus nützlich sein, weshalb gewisse Anwendungen immer noch in 'plain' Assembly code geschrieben werden.\\ Durch die Hardware nähe und die daraus resultierende schnelligkeit könnte man denken das sich Assembly code gut für Kryptografie eignet. Der Aufwand und die Komplexität ein Krypto Algorythmus in Assembly zu realisieren sind jedoch meist zu groß sodass 'High level' Sprachen beforzugt werden.\\
Ein weiterer Nachteil ist die Tatsache das Assembleysprachen sehr spezialisiert auf die jeweiligen Computerarchitekturen ausgelegt sind. Das heißt das Spezifikationen und Befehlssätze nur auf dieser bestimmten Auslegung laufen. Dies hat zur Folge das die Übertragung auf eine andere Architektur mit sehr viel Aufwand und Anpassung im Quelltext verbunden wäre!\\
Des weiteren haben die wenigsten Assembleysprachen die Notwendigen Operationen bzw. Befehle die für Kryptografisches arbeiten Notwendig sind. Einfache arithmetische Operationen wie Addition oder Vergleiche von Ganzzahlen sind zwar vorhanden, komplexere Operationen wie Modulo Rechung oder Gleitkomma arithmetik nur vereinzelt und müssten sonst von Grund auf eigens definiert werden!\\
Trotz der vielen genannten Nachteile gibt es Verwendung in Bereichen in denen 'High level' Sprachen nicht genug Effizients bieten. Implementierungen in C sind zwar wesentlich einfacher zu schreiben und lesen, jedoch wäre eine Optimierte Umsetzung des gleichen Programmes in Assembly trotz moderner hoch optimierter Compiler für gewisse Aufgaben schneller.\\
Der vom C Compiler generierte Assembly code ist also potenziell schlechter bzw. ineffizienter als ein von Menschen geschriebener Assembly code!\\ Ein Grund dafür ist die Tatsache das Compiler schlecht mit großen Zahlen umgehen können. Das heißt speziell in der Kryptografie in der viel und oft mit großen Integers gearbeitet wird ist es durchaus sinnvoll gewisse Rechenoperation mit 'plain Assembly code' zu realisieren.
\newpage
Folgendes Beispiel veranschaulicht dies indem ein einfaches Programm in C anhand von GCC kompiliert wird. Anschließend wird die gleiche Operation in 'plain Assembly' nachgeschrieben. Wie sich zeigt ist der von GCC generierte Assemblycode wesentlich länger und langsamer.\\
Das C Programm realisiert das Modul addcarry u64, welches die Summe zweier 'unsigned Integers' und einem carry-in computiert und den Wert des carrys outs zurückgibt!
\vspace{7 mm}
\begin{lstlisting}
#include <stdint.h>
#include <x86intrin.h>

void add256(uint64_t a[4], uint64_t b[4]){
	uint8_t carry = 0;
	for (int i = 0; i < 4; ++i)
		carry = _addcarry_u64(carry, a[i], b[i], &a[i]);
}
\end{lstlisting}
\vspace{7 mm}
Nun der von GCC kompilierte Assemblycode:
\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    (%rdi), %rax
setc    %dl
movq    %rax, (%rdi)
movq    8(%rdi), %rax
addb    $-1, %dl
adcq    8(%rsi), %rax
setc    %dl
movq    %rax, 8(%rdi)
movq    16(%rdi), %rax
addb    $-1, %dl
adcq    16(%rsi), %rax
setc    %dl
movq    %rax, 16(%rdi)
movq    24(%rsi), %rax
addb    $-1, %dl
adcq    %rax, 24(%rdi)
ret
\end{lstlisting}
\newpage
Schreibt man das Programm nun in optimiertem Assemblycode zeigt sich das dieser wensentlich kompakter ist! \\


\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    %rax, (%rdi)
movq    8(%rsi), %rax
adcq    %rax, 8(%rdi)
movq    16(%rsi), %rax
adcq    %rax, 16(%rdi)
movq    24(%rsi), %rax
adcq    %rax, 24(%rdi)
retq
\end{lstlisting}
Auch Laufzeiten sind merklich verkürzt!\\
Je nach Kompiler und Architektur kann selbst geschriebener Assemblycode bis zu doppelt so schnell wie kompilierter Code sein!\\

\vspace{2 mm}

Stellen wir also fest das 'plain' Assemblycode durch seine schnelligkeit und Effizients für gewisse Aufgaben und spezialisierte Bereiche durchaus einen Vorteil gegenüber High level Sprachen bietet!\\
Die Frage ist nun ob das auch für Kryptografische Anwendungen gilt?!\\
Wie anfangs erwähnt sind in den meisten Assembly Sprachen nicht alle notwendigen Operationen wie modulor Rechnung vorhanden. So könnte man diese zwar eigens nachprogrammieren, jedoch stünde der Aufwand in keinem Verhältnis zu der schnelleren Laufzeit die man daduruch gewinnen würde.\\
Das hat zur Folge das in praxis kaum komplexere Krypto Anwendungen in 'plain' Assembly geschrieben werden! Stattdessen werden kleine Verschlüsselungsalgorythmen wie TEA oder Rot13 realisiert.\\
Im folgenden wird der Tiny Encryption Algorithm in Assembly implementiert. Dieser ist eine Blockverschlüsselung die für Ihre einfachheit, Kompaktheit und daraus resultierende Schnelligkeit bekannt ist. 
Tea ist eine Feistelchiffre und arbeitet mit 64-Bit Blöcken und einem 127-bit langem Schlüssel.\\
Der Assemblycode ist in x86 geschrieben.\\
\dots









\newpage
\textbf{Tiny Encryption Algorythm on Assembly x86}
\begin{lstlisting}
pushl  %ebp
movl   %esp, %ebp 	Eingabe 3 Woerter und Zweisung Lokalem Speicher 
subl   $12, %esp	auf den Stack

movl   %ebx, 0(%esp)
movl   %esi, 4(%esp)	Speichern der callee-save registers
movl   %edi, 8(%esp)

movl    8(%ebp), %eax  
movl   12(%ebp), %edx  	Einladen des Message arrays!

movl   0(%eax), %esi	Einladen beider 32-bit Woerter
movl   4(%eax), %edi	der Nachricht
movl   $0x9E3779B9, %ecx 

.tea_encrypt_top:	Beginn der Schleife

movl   %edi, %ebx
shll   $4, %ebx
addl   0(%edx), %ebx
leal   (%edi,%ecx), %eax
xorl   %eax, %ebx
movl   %edi, %eax	Verschluesselung der Nullten Nachricht.
shrl   $5, %eax
addl   4(%edx), %eax
xorl   %eax, %ebx
addl   %ebx, %esi

movl   %esi, %ebx
shll   $4, %ebx
addl   8(%edx), %ebx
leal   (%esi,%ecx), %eax
xorl   %eax, %ebx	Verschluesselung der ersten Nachricht
movl   %esi, %eax	ueber den selben Weg
shrl   $5, %eax
addl   12(%edx), %eax
xorl   %eax, %ebx
addl   %ebx, %edi
 
 addl   $0x9E3779B9, %ecx
 cmpl   $0x6526B0D9, %ecx  Erhoehung der Runden Konstanten.
 jne    .tea_encrypt_top
 
 movl   8(%ebp), %eax
 movl   %esi, 0(%eax)	Ende der Schleife. Speicherung der Nachricht
 movl   %edi, 4(%eax)	in einem Array
 
 movl   0(%esp), %ebx
 movl   4(%esp), %esi	
 movl   8(%esp), %edi
 
 addl   $12, %esp	Freigeben des Stacks 
 popl   %ebp	
 retl
\end{lstlisting}
\vspace{10mm}
Ein Vorteil der x86 Architektur ist die Tatsache das arithmetische operationen aus dem Speicher lesen und schreiben können.Daraus resultiert die relative kompaktheit des codes! Dies ist nicht für alle Assembly Sprachen gegeben!\\
\dots
\subsection{Biblotheken}
Von Biblotheken in 'plain' Assembly kann man nicht wirklich Sprechen. Vielmehr existieren Biblotheken in  C/C++ die man je nach Architektur auch für Assembly verwenden kann.
Dadurch  das es nicht eine bestimmte Assemblysprache gibt, existiert beispielweise auch keine Standart Biblothek. Jede Architektur hat ihre eigenen module und Implementierungen. Durch diese fehlende Einheitlichkeit gibt es wenig Dokumentation speziell im Krypto Bereich!\\
Denoch existieren beispielweise in ssl oder Libsodium Implementierungen in 'Hand geschriebenem' Assembly!
Da es damit auch keine Krypto Biblotheken gibt, müssen jegliche Operationen selber Programmiert werden.


\newpage
\section{C}
C ist eine alte, aber dennoch sehr verbreitete und genutze Sprache. \\Heutzutage wird sie als extrem Hardware-nah bezeichnet, ist im gegensatz zu Assembly jedoch durchaus als 'High level' Sprache zu bezeichnen. Ein riesen Vorteil gegenüber Assembleysprachen ist die viel bessere lesbarkeit und Plattformunabhängigkeit.
Auch sind nahezu alle Mathematischen Operationen die für Krypto-Anwendungen benötigt werden vorhanden oder können einfach durch diverse Biblotheken eingebunden werden. Des weiteren ist C im Vergleich zu heutigen 'High level' Sprachen extrem schnell. Zwar gibt es wie erwähnt gewisse Fälle in denen Kompiler Optimierungsprobleme haben, jedoch gilt dies nur im direkten Vergleich zu Assembly Sprachen!\\
Nachteile der Sprache sind, insbesondere bezogen auf Kryptografie die hohe Anzahl an sicherheitsrelevanten Fehlermöglichkeiten. Dadurch das ein Programmierer nahezu uneingeschränkt mit Zeigern und Speicherstrukturen arbeiten kann und Kompiler nur teilweise auf Sicherheit prüfen gibt es ein recht hohes Potential Angreifbare Fehler zu produzieren.
Unter anderem sind das:
\begin{itemize}
 \item Hängende Zeiger\\
 Zeiger die auf gar keinen oder den falschen Speicherbereich verweisen. Dies kann bei Implementierung eines Krypto-Algorythmus in C zu unsicherheiten oder dem kompletten Ausfall der Anwendung führen!
  
 \item Pufferüberlauf\\
100
  Ein zu klein verwiesener Speicher kann dazu führen das auch hier schadcode Platziert werden kann oder das Programm abstürzt!
  \item Race conditions\\
  Dieser Fehler tritt auf wenn zeitliche koordinierung von Programmaufgaben schlecht oder gar nicht Synchroniziert werden. Klassische Beispiele sind Signale in der Systemprogrammierung oder Speicher operationen auf einem Mikroprozessor.
  
 
\end{itemize}
Des weiteren exisiert keine automatische Laufzeitüberpürfung, was beispielweise bei Kryptoanalysen Probleme bereitet.\\
Die Eignung von C für Krypto-Anwendungen hängt also stark von der Expertise des Programmierers ab! Ist dieser in der Lage die erwähnten Risiken zu entschärfen bzw. zu umgehen, überweigen die erwähnten Vorteile von Schnelligkeit und Effizients!\\
In Realität gibt es jedoch immer wieder Fälle bei denen schlechter, unsicherer C Code zu gefährlichen Sicherheitslücken führt! Schaut man sich beispielweise die Patch notes von Mozilla Firefox an, fällt auf das viele Schwachstellen auf genau solch Probleme zurückzuführen sind! Monatlich gibt es bis zu 10 mittlere, teilweise schwerwiegende Sicherheitsfixes, die meist durch Speicherüberläufe in C/C++ entstehen.\\
\newpage
Ein berühmter sehr kostspieliger Fall trat 2014 in Form des 'Heartbleed' exploites auf. Diese Lücke machte es Angreifern möglich sensitive Informationen wie Passwörter oder Bankdaten von Webseiten abzugreifen. Zurückzuführen war das ganze auf eine Fehlerhafte Speicherimplementierung in OpenSSl was in C geschrieben ist. 
OpenSSl ist eine Software-Biblothek die verschiedene Netzwerkprotokolle und Verschlüsselungen umfasst, unter anderem TLS bzw. SSL. Diese werden genutzt um eine sichere Datenübertragung  zwischen Client und Host zu gewährleisten. Grob beschrieben führt TLS ein Handshake durch, bei dem ein Schlüsselaustauch sowie eine Authentisierung stattfindet. Über den TLS Record wird nun anhand des Schlüssels eine sichere Verbindung aufgebaut. Um zu gewährleisten das diese sichere Verbidung auch nach längerer inaktivität gegeben ist, sendet TLS regelmäßig einen sogenannten 'heartbeat request'. Dieser besteht aus einem chiffrierten Datenblock. Der Empfänger antwortet mit dem exakt gleiche Datenstück und beweist damit das die sichere Verbindung noch besteht! Wichtig hierbei ist das die ursprüngliche Anfrage Informationen über seine länge enthählt. Dadurch weiß der Empfänger wie viel Speicher für die Nachricht freigeben muss. An diesem Punkt trat die Schwachstelle auf. Seitens des Empfängers wurde nähmlich nicht überprüft ob die angegebene lönge stimmte! Das heißt ein 'heartbeat request' konnte mit 50kb angegeben sein, hatte jedoch eine tatsächliche länge von nur 25kb. Der betrofene Empfänger gab also diese 50kb frei, speicherte die eigentlichen 25kb und versand diese anschließend wieder mitsamt 25kb weiterer Daten die sich in diesem Speicher befanden! Der Angreifer hat nun also diese Daten seitens des Empfängers abgegriffen. Dies zeigt wie schnell unsauberer Code in katastrophalen Schwachstellen enden kann. Der Auslöser des ganzen kann auf eine einzelne Zeile im C Code zurückgeführt werden:

\begin{center}
\begin{lstlisting}
	{
		memcpy(bp, pl, payload);
	}
\end{lstlisting}
Das Kommando 'memcpy()' kopiert Daten aus dem Speicher 'pl' in 'pb'.\\ Das Argument 'payload' gibt die länge des kopierten Datenstückes an!\\ 
\end{center}
Trotz der Tatsache das OpenSSl damals wie heute Open Source ist und somit jeder diese Sicherheitslücke hätte sehen können, wurde dies erst in Folge des heartbleed exploites gefixt! Dies zeigt erneut das Risiko Krypto Anwendungen in C zu schreiben!\\
Denoch ist C die wahrscheinlich meist genutzte Sprache um Kryptografische Anwendungen umzusetzen. Auch viele Verschlüsselungsbiblotheken von anderen Sprachen, sind letztendlich C Verbunde!
\vspace{2.5mm}

Obwohl Biblotheken viele arbeiten wie Hashing/Chiffrierung etc. abnehmen, kann man diese Operationen natürlich auch selber in 'plain' C nachschreiben. Dies wird im folgenden anhand des One time Pads gezeigt! 
\newpage



\begin{verbatim}
#include<stdio.h>
#include<string.h>
#include<ctype.h>

main(int argc, char *argv[])
{
    //Jegliche Eingaben werden in Großbuchstaben convertiert 
    //und Leerzeilen werden entfernt.
    int i,j,len1,len2,numstr[100],numkey[100],numcipher[100];
    char str[100],key[100],cipher[100];
    printf("Bitte geben Sie den zu verschlüsselnden Text ein\n");
    gets(str);
    for(i=0,j=0;i<strlen(str);i++) {
        if(str[i]!=' ') {
             str[j]=toupper(str[i]);   //toupper ist eine C interne Funktion
             j++;                      //die hier anhand einer For-Schleife
        }                              //die Eingaben in Großbuchstaben umschreibt
    }
    str[j]='\0';
    //Erhalt des Klartextes (nummerisch)
    for(i=0;i<strlen(str);i++) {
       numstr[i]=str[i]-'A';    
    }   
    printf("Bitte einen Zufälligen Text eingeben(Länge beliebig)\n");
    gets(key);
    for(i=0,j=0;i<strlen(key);i++) {
        if(key[i]!=' ') {
            key[j]=toupper(key[i]);   
            j++;
        }
    }
    key[j]='\0';
    //Erhalt des OTP bzw. Key
    for(i=0;i<strlen(key);i++) {
        numkey[i]=key[i]-'A';    
    }  

    for(i=0;i<strlen(str);i++) {
        numcipher[i]=numstr[i]+numkey[i];
    }
   
    for(i=0;i<strlen(str);i++) {
        if(numcipher[i]>25) {
           numcipher[i]=numcipher[i]-26;
        }
    }
    printf("Der One Time Pad Ciphertext ist\n");
    for(i=0;i<strlen(str);i++) {
        printf("%c",(numcipher[i]+'A')); 
    }
    printf("\n");

}

\end{verbatim}
\dots\\
Durch benutzen von 'gets()' setzt man das Programm ein recht hohes Risiko zu einem Buffer Overflow aus! Deshalb gilt die ungeschriebene Regel ' Dont write your own krypto'.
Bei Ausführung des Programmes zeigt sich folgendes:
\begin{figure}[h]

\includegraphics[scale=0.41]{otp.png}     
\end{figure}
\newpage
\subsection{Biblotheken}
Als C 1976 erschien, war die Notwendigkeit von kryptographischen Verfahren und deren Implementierung noch lange nicht so hoch wie heute. Daher gab es anfangs auch wenige Bibliotheken speziell im Krypto-Bereich! Inzwischen hat C jedoch  eine breite Auswahl an Bibliotheken für kryptographische Verfahren die heute noch regelmäßig Updates bekommen.\\

\vspace{2mm}
\textbf{OpenSSL}: Die wohl bekannteste und meist genutzte Biblothek für Kryptografie. Nahezu alle HTTPS Websites nutzen diese Biblothek.\\
\dots\\
Um OpenSSL für C Code zu verwenden sollten folgende Header eingebunden werden.
\begin{verbatim}
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/rsa.h>
#include <openssl/x509.h>
\end{verbatim}
Je nach Verwendung müssen nun die notwendigen Initialisierungen durchgeführt werden. Dies könnte man anhand folgender Funktion umsetzen:
\begin{verbatim}
void init_ssl() {
     SSL_library_init(); 
     SSL_load_error_strings();
     ....
}
\end{verbatim}
Folgender Funktionsauschnitt generiert beispielweise einen RSA Key:
\begin{verbatim}
RSA *rsa;
rsa = RSA_new();
//RSA_generate_key_ex(r, bits, bn, NULL);

RSA_generate_key_ex(
	r,  // Zeiger auf RSA Struktur 
	bits, // Anzahl der bits für den Schlüssel zB. 2048
	bn,   // Zugeteilter Exponent  
	NULL, // Callback 
);

\end{verbatim}
Hier wird anschaulich lediglich ein einzelner Key generiert! Ein vollständiges Programm müsste zudem den Public und Private Key noch zwischenspeichern.

\newpage
Auch ist es möglich OpenSSl Kommandos die eigentlich in einer Shell ausgeführt werden in C Code zu implementieren.
Folgendes Kommando Generiert einen Private Key und ein Zertifikat.\\

\textbf{openssl req -out geekflare.csr -newkey rsa:2048 -nodes -keyout geekflare.key}

In einem C Programm eingebunden:
\begin{verbatim}
int main () {
   char c[50]; 
   strcpy( c, "openssl req -out geekflate.csr -newkey rsa:2084 ...." );
   system(c);
   return 0;
} 
\end{verbatim}
Diese Umsetzung von OpenSSL in C ist jedoch nur für kleinere Anwendungen\\ gebräuchlich!\\
\\
\textbf{Cryptlib}:
Bietet ein High-Level Interface zur einfachen Implementierung von Sicherheits-
funktionen. Sie ist komplett in C geschrieben, kann und wird aber auch in JAVA, C++ und weiteren Sprachen verwendet. Cryptlib umfasst unter anderem SSL/TLS, OpenPGP, MIME und viele weitere Protokolle und Standarts. Auch Krypto-Algorithmen wie AES,DES, RSA oder SHA-1/2 sind vertreten. Für die Verwendung in C Code sind 
folgende Header zu verwenden:
\begin{verbatim}
#include "cryptlib.h"
\end{verbatim}
Initialisierungen:
\begin{verbatim}
using cryptlib;
crypt.Init();
...
crypt.End();
\end{verbatim}
Hier wird nun eine Anwendung mit Sha realisiert:
\begin{verbatim}
Encrypt:
var cryptLib = require(’cryptlib’),
iv = cryptLib.generateRandomIV(16), //16 bytes = 128 bit
key = cryptLib.getHashSha256(’my secret key’, 32), //32 bytes = 256 bits
encryptedText = cryptLib.encrypt(’This is the text to be encrypted’, key, iv);
Decrypt:
var cryptLib = require(’cryptlib’),
iv = ’iv vector used for encryption’,
key = cryptLib.getHashSha256(’my secret key’, 32), //32 bytes = 256 bits
originalText = cryptLib.decrypt(’M2rfrn9DqNHJe3Hev9nMxKKgIHoqUsc7FJM+tBGxIrl3Wk9UeKIQ
\end{verbatim}
\dots
\newpage
Weitere Relevante Krypto Biblotheken sind:
\begin{itemize}
\item libsodium\\
asdasdasd \dots
\item LibreSSL
\item Libgcrypt
\item wolfCrypt
\item \dots
\end{itemize}

Es existieren mehr als 20 aktiv geführte Krypto Biblotheken in C. Dazu kommen etliche Github Repos die Krypto Anwendungen realisieren.\\
Nimmt man dies alles zusammen stellt man fest das C nach wie vor die meist genutze Sprache für Krypotgrafie ist!\\
\dots
\newpage
\section{C++}
C++ kann man als direkte Erweiterung von C beschreiben. Die Sprache bietet sowohl  


\end{document}


///////////////////////
NEW
//////////////////

\documentclass[a4paper,12pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{tabto}
\usepackage{listings}


\title{Implementierung von Kryptologie in Programmiersprachen}
\subtitle{Kryptologie 2}
\author{Moritz Rupp}
\date{Wintersemester 2020}


% Mathepakete
\usepackage{amsfonts}
\usepackage{amsmath}


\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


\section{Abstract}


\dots\\
\dots\\
\dots\\

Wir werden anfangen mit 'Low level' sprachen wie Assemply und C um anschließend 'High level' Sprachen wie Java, Python und Java Script unter die Lupe zu nehmen!\\
Anschließend werden die jeweiligen Sprachen auf Ihre tauglichkeit für Kryptograhpie bewertet..\\
Kriterien wie schnelligkeit, einfachheit, sicherheit und \\
\dots\\
\\
Eines der wichtigsten Regeln in der Kryptografie besagt man solle nie seine eigene Krypto schreiben.
Das heißt dass man die Verschlüsselungsalgorithmen niemals selbst programmieren oder gar neue, für sich maßgeschneiderte Implementierungen erstellen sollte. Grund dafür ist die extrem hohe anfälligkeit die solche Versuche mit sich führen würden.
Kryptografische Verfahren haben einen langen Testprozess durchlaufen. Über viele Jahr werden sie von Experten der Prüfung un terzogen. Trotzdem gibt es immer wieder erfolgreiche Angriffe auf vermeintlich sichere Krypto.\\

\dots\\
\textbf{Was sind die Anforderungen an Programmiersprachen?}\\
\dots\\
Kerckofs princible sollte auch für Kryptografie in Code gelten!
Es gibt Versuche den code an sich zu verschlüsseln oder zu verbergen, aber das programm sollte sicher genug sein, sodass selsbt bei kompletter transparanz es nicht möglich ist die Krypotgrafie zu brechen!\\
Deshlab kerkos prinzip- einfach nur den Schlüssel geheim zu halten! Logischerweiße sollte der code nicht  zum entschlüsseln helfen!\\
Biblotheken stellen hierbei die direkteste Umsetzung von Kryptografie in Coding dar! DDeshlab wird hier das Hauptaugenmerk auf Biblotheken beruhen!\\
\dots
Even   if   a   mathematical   model   of   an   algorithm   (or   a protocol)  has  been  proven  to  be  secure,  it  is  not  guaranteed that implementation of the algorithm is also secure ...\\
If  in  the  software  development,  cryptographic  algorithms are    coded    from    scratch,    then    possible    errors    in    theimplementation  of  cryptographic  algorithms  are  programming errors –  errors  of  an  improper  mapping  of  operations  and logics   of   algorithms   to   the   source   code   by   softwareprogrammers.  Programming  errors  in  cryptographic  software include the following errors: •bugs – which are common for the entire programming and not  specific  to  cryptography;   methods  for  controlling them are not discussed here separately; •usage  of  cryptographic  algorithms  in  an  improper  way(see the corresponding section of this paper); •usage  of  improper  algorithms –  for  example,  if  a  stream cipher   assumes   a   pseudo-random   number   generator (PRNG)  to  be  used,  then  there  should  be  used  only cryptographically    secure    PRNGs,    but    not    simple generators    which    are    built    in    some    programming languages (e.g. the function std::rand() in C++). To avoid most of programming errors in implementation of cryptographic  algorithms,  and  to  simplify  and  shorten  the implementation   process,   there   are   provided   a   number   of cryptographic  libraries  with  implementations  of  commonly used   (and   sometimes   also   many   other,   not   so   popular) cryptographic algorithms.


\newpage


\section{Assembly}
Assembly sprachen stellen die tiefste Ebene der Programmiersprachen dar.
Sie laufen extrem Hardware nah und können dadurch alle Möglichkeiten eines Mikroprozessors nutzen. Dies ist zwar heutzutage meist nicht erforderlich, kann aber auf kleineren Endgeräten wie 'Iot devices' durchaus nützlich sein, weshalb gewisse Anwendungen immer noch in 'plain' Assembly code geschrieben werden.\\ Durch die Hardware nähe und die daraus resultierende schnelligkeit könnte man denken das sich Assembly code gut für Kryptografie eignet. Der Aufwand und die Komplexität ein Krypto Algorythmus in Assembly zu realisieren sind jedoch meist zu groß sodass 'High level' Sprachen beforzugt werden.\\
Ein weiterer Nachteil ist die Tatsache das Assembleysprachen sehr spezialisiert auf die jeweiligen Computerarchitekturen ausgelegt sind. Das heißt das Spezifikationen und Befehlssätze nur auf dieser bestimmten Auslegung laufen. Dies hat zur Folge das die Übertragung auf eine andere Architektur mit sehr viel Aufwand und Anpassung im Quelltext verbunden wäre!\\
Des weiteren haben die wenigsten Assembleysprachen die Notwendigen Operationen bzw. Befehle die für Kryptografisches arbeiten Notwendig sind. Einfache arithmetische Operationen wie Addition oder Vergleiche von Ganzzahlen sind zwar vorhanden, komplexere Operationen wie Modulo Rechung oder Gleitkomma arithmetik nur vereinzelt und müssten sonst von Grund auf eigens definiert werden!\\
Trotz der vielen genannten Nachteile gibt es Verwendung in Bereichen in denen 'High level' Sprachen nicht genug Effizients bieten. Implementierungen in C sind zwar wesentlich einfacher zu schreiben und lesen, jedoch wäre eine Optimierte Umsetzung des gleichen Programmes in Assembly trotz moderner hoch optimierter Compiler für gewisse Aufgaben schneller.\\
Der vom C Compiler generierte Assembly code ist also potenziell schlechter bzw. ineffizienter als ein von Menschen geschriebener Assembly code!\\ Ein Grund dafür ist die Tatsache das Compiler schlecht mit großen Zahlen umgehen können. Das heißt speziell in der Kryptografie in der viel und oft mit großen Integers gearbeitet wird ist es durchaus sinnvoll gewisse Rechenoperation mit 'plain Assembly code' zu realisieren.
\newpage
Folgendes Beispiel veranschaulicht dies indem ein einfaches Programm in C anhand von GCC kompiliert wird. Anschließend wird die gleiche Operation in 'plain Assembly' nachgeschrieben. Wie sich zeigt ist der von GCC generierte Assemblycode wesentlich länger und langsamer.\\
Das C Programm realisiert das Modul addcarry u64, welches die Summe zweier 'unsigned Integers' und einem carry-in computiert und den Wert des carrys outs zurückgibt!
\vspace{7 mm}
\begin{lstlisting}
#include <stdint.h>
#include <x86intrin.h>

void add256(uint64_t a[4], uint64_t b[4]){
	uint8_t carry = 0;
	for (int i = 0; i < 4; ++i)
		carry = _addcarry_u64(carry, a[i], b[i], &a[i]);
}
\end{lstlisting}
\vspace{7 mm}
Nun der von GCC kompilierte Assemblycode:
\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    (%rdi), %rax
setc    %dl
movq    %rax, (%rdi)
movq    8(%rdi), %rax
addb    $-1, %dl
adcq    8(%rsi), %rax
setc    %dl
movq    %rax, 8(%rdi)
movq    16(%rdi), %rax
addb    $-1, %dl
adcq    16(%rsi), %rax
setc    %dl
movq    %rax, 16(%rdi)
movq    24(%rsi), %rax
addb    $-1, %dl
adcq    %rax, 24(%rdi)
ret
\end{lstlisting}
\newpage
Schreibt man das Programm nun in optimiertem Assemblycode zeigt sich das dieser wensentlich kompakter ist! \\


\begin{lstlisting}
add256:
movq    (%rsi), %rax
addq    %rax, (%rdi)
movq    8(%rsi), %rax
adcq    %rax, 8(%rdi)
movq    16(%rsi), %rax
adcq    %rax, 16(%rdi)
movq    24(%rsi), %rax
adcq    %rax, 24(%rdi)
retq
\end{lstlisting}
Auch Laufzeiten sind merklich verkürzt!\\
Je nach Kompiler und Architektur kann selbst geschriebener Assemblycode bis zu doppelt so schnell wie kompilierter Code sein!\\

\vspace{2 mm}

Stellen wir also fest das 'plain' Assemblycode durch seine schnelligkeit und Effizients für gewisse Aufgaben und spezialisierte Bereiche durchaus einen Vorteil gegenüber High level Sprachen bietet!\\
Die Frage ist nun ob das auch für Kryptografische Anwendungen gilt?!\\
Wie anfangs erwähnt sind in den meisten Assembly Sprachen nicht alle notwendigen Operationen wie modulor Rechnung vorhanden. So könnte man diese zwar eigens nachprogrammieren, jedoch stünde der Aufwand in keinem Verhältnis zu der schnelleren Laufzeit die man daduruch gewinnen würde.\\
Das hat zur Folge das in praxis kaum komplexere Krypto Anwendungen in 'plain' Assembly geschrieben werden! Stattdessen werden kleine Verschlüsselungsalgorythmen wie TEA oder Rot13 realisiert.\\
Im folgenden wird der Tiny Encryption Algorithm in Assembly implementiert. Dieser ist eine Blockverschlüsselung die für Ihre einfachheit, Kompaktheit und daraus resultierende Schnelligkeit bekannt ist. 
Tea ist eine Feistelchiffre und arbeitet mit 64-Bit Blöcken und einem 127-bit langem Schlüssel.\\
Der Assemblycode ist in x86 geschrieben.\\
\dots









\newpage
\textbf{Tiny Encryption Algorythm on Assembly x86}
\begin{lstlisting}
pushl  %ebp
movl   %esp, %ebp 	Eingabe 3 Woerter und Zweisung Lokalem Speicher 
subl   $12, %esp	auf den Stack

movl   %ebx, 0(%esp)
movl   %esi, 4(%esp)	Speichern der callee-save registers
movl   %edi, 8(%esp)

movl    8(%ebp), %eax  
movl   12(%ebp), %edx  	Einladen des Message arrays!

movl   0(%eax), %esi	Einladen beider 32-bit Woerter
movl   4(%eax), %edi	der Nachricht
movl   $0x9E3779B9, %ecx 

.tea_encrypt_top:	Beginn der Schleife

movl   %edi, %ebx
shll   $4, %ebx
addl   0(%edx), %ebx
leal   (%edi,%ecx), %eax
xorl   %eax, %ebx
movl   %edi, %eax	Verschluesselung der Nullten Nachricht.
shrl   $5, %eax
addl   4(%edx), %eax
xorl   %eax, %ebx
addl   %ebx, %esi

movl   %esi, %ebx
shll   $4, %ebx
addl   8(%edx), %ebx
leal   (%esi,%ecx), %eax
xorl   %eax, %ebx	Verschluesselung der ersten Nachricht
movl   %esi, %eax	ueber den selben Weg
shrl   $5, %eax
addl   12(%edx), %eax
xorl   %eax, %ebx
addl   %ebx, %edi
 
 addl   $0x9E3779B9, %ecx
 cmpl   $0x6526B0D9, %ecx  Erhoehung der Runden Konstanten.
 jne    .tea_encrypt_top
 
 movl   8(%ebp), %eax
 movl   %esi, 0(%eax)	Ende der Schleife. Speicherung der Nachricht
 movl   %edi, 4(%eax)	in einem Array
 
 movl   0(%esp), %ebx
 movl   4(%esp), %esi	
 movl   8(%esp), %edi
 
 addl   $12, %esp	Freigeben des Stacks 
 popl   %ebp	
 retl
\end{lstlisting}
\vspace{10mm}
Ein Vorteil der x86 Architektur ist die Tatsache das arithmetische operationen aus dem Speicher lesen und schreiben können.Daraus resultiert die relative kompaktheit des codes! Dies ist nicht für alle Assembly Sprachen gegeben!\\
\dots
\subsection{Biblotheken}
Von Biblotheken in 'plain' Assembly kann man nicht wirklich Sprechen. Vielmehr existieren Biblotheken in  C/C++ die man je nach Architektur auch für Assembly verwenden kann.
Dadurch  das es nicht eine bestimmte Assemblysprache gibt, existiert beispielweise auch keine Standart Biblothek. Jede Architektur hat ihre eigenen module und Implementierungen. Durch diese fehlende Einheitlichkeit gibt es wenig Dokumentation speziell im Krypto Bereich!\\
Denoch existieren beispielweise in ssl oder Libsodium Implementierungen in 'Hand geschriebenem' Assembly!
Da es damit auch keine Krypto Biblotheken gibt, müssen jegliche Operationen selber Programmiert werden.


\newpage
\section{C}
C ist eine alte, aber dennoch sehr verbreitete und genutze Sprache. \\Heutzutage wird sie als extrem Hardware-nah bezeichnet, ist im gegensatz zu Assembly jedoch durchaus als 'High level' Sprache zu bezeichnen. Ein riesen Vorteil gegenüber Assembleysprachen ist die viel bessere lesbarkeit und Plattformunabhängigkeit.
Auch sind nahezu alle Mathematischen Operationen die für Krypto-Anwendungen benötigt werden vorhanden oder können einfach durch diverse Biblotheken eingebunden werden. Des weiteren ist C im Vergleich zu heutigen 'High level' Sprachen extrem schnell. Zwar gibt es wie erwähnt gewisse Fälle in denen Kompiler Optimierungsprobleme haben, jedoch gilt dies nur im direkten Vergleich zu Assembly Sprachen!\\
Nachteile der Sprache sind, insbesondere bezogen auf Kryptografie die hohe Anzahl an sicherheitsrelevanten Fehlermöglichkeiten. Dadurch das ein Programmierer nahezu uneingeschränkt mit Zeigern und Speicherstrukturen arbeiten kann und Kompiler nur teilweise auf Sicherheit prüfen gibt es ein recht hohes Potential Angreifbare Fehler zu produzieren.
Unter anderem sind das:
\begin{itemize}
 \item Hängende Zeiger\\
 Zeiger die auf gar keinen oder den falschen Speicherbereich verweisen. Dies kann bei Implementierung eines Krypto-Algorythmus in C zu unsicherheiten oder dem kompletten Ausfall der Anwendung führen!
  
 \item Pufferüberlauf\\
  Ein zu klein verwiesener Speicher kann dazu führen das auch hier schadcode Platziert werden kann oder das Programm abstürzt!
  \item Race conditions\\
  Dieser Fehler tritt auf wenn zeitliche koordinierung von Programmaufgaben schlecht oder gar nicht Synchroniziert werden. Klassische Beispiele sind Signale in der Systemprogrammierung oder Speicher operationen auf einem Mikroprozessor.
  
 
\end{itemize}
Des weiteren exisiert keine automatische Laufzeitüberpürfung, was beispielweise bei Kryptoanalysen Probleme bereitet.\\
Die Eignung von C für Krypto-Anwendungen hängt also stark von der Expertise des Programmierers ab! Ist dieser in der Lage die erwähnten Risiken zu entschärfen bzw. zu umgehen, überwiegen die erwähnten Vorteile von Schnelligkeit und Effizients!\\
In Realität gibt es jedoch immer wieder Fälle bei denen schlechter, unsicherer C Code zu gefährlichen Sicherheitslücken führt! Schaut man sich beispielweise die Patch notes von Mozilla Firefox an, fällt auf das viele Schwachstellen auf genau solch Probleme zurückzuführen sind! Monatlich gibt es bis zu 10 mittlere, teilweise schwerwiegende Sicherheitsfixes, die meist durch Speicherüberläufe in C/C++ entstehen.\\
\newpage
Ein berühmter sehr kostspieliger Fall trat 2014 in Form des 'Heartbleed' exploites auf. Diese Lücke machte es Angreifern möglich sensitive Informationen wie Passwörter oder Bankdaten von Webseiten abzugreifen. Zurückzuführen war das ganze auf eine Fehlerhafte Speicherimplementierung in OpenSSl was in C geschrieben ist. 
OpenSSl ist eine Software-Biblothek die verschiedene Netzwerkprotokolle und Verschlüsselungen umfasst, unter anderem TLS bzw. SSL. Diese werden genutzt um eine sichere Datenübertragung  zwischen Client und Host zu gewährleisten. Grob beschrieben führt TLS ein Handshake durch, bei dem ein Schlüsselaustauch sowie eine Authentisierung stattfindet. Über den TLS Record wird nun anhand des Schlüssels eine sichere Verbindung aufgebaut. Um zu gewährleisten das diese sichere Verbidung auch nach längerer inaktivität gegeben ist, sendet TLS regelmäßig einen sogenannten 'heartbeat request'. Dieser besteht aus einem chiffrierten Datenblock. Der Empfänger antwortet mit dem exakt gleiche Datenstück und beweist damit das die sichere Verbindung noch besteht! Wichtig hierbei ist das die ursprüngliche Anfrage Informationen über seine länge enthählt. Dadurch weiß der Empfänger wie viel Speicher für die Nachricht freigeben muss. An diesem Punkt trat die Schwachstelle auf. Seitens des Empfängers wurde nähmlich nicht überprüft ob die angegebene lönge stimmte! Das heißt ein 'heartbeat request' konnte mit 50kb angegeben sein, hatte jedoch eine tatsächliche länge von nur 25kb. Der betrofene Empfänger gab also diese 50kb frei, speicherte die eigentlichen 25kb und versand diese anschließend wieder mitsamt 25kb weiterer Daten die sich in diesem Speicher befanden! Der Angreifer hat nun also diese Daten seitens des Empfängers abgegriffen. Dies zeigt wie schnell unsauberer Code in katastrophalen Schwachstellen enden kann. Der Auslöser des ganzen kann auf eine einzelne Zeile im C Code zurückgeführt werden:

\begin{center}
\begin{lstlisting}
	{
		memcpy(bp, pl, payload);
	}
\end{lstlisting}
Das Kommando 'memcpy()' kopiert Daten aus dem Speicher 'pl' in 'pb'.\\ Das Argument 'payload' gibt die länge des kopierten Datenstückes an!\\ 
\end{center}
Trotz der Tatsache das OpenSSl damals wie heute Open Source ist und somit jeder diese Sicherheitslücke hätte sehen können, wurde dies erst in Folge des heartbleed exploites gefixt! Dies zeigt erneut das Risiko Krypto Anwendungen in C zu schreiben!\\
Denoch ist C die wahrscheinlich meist genutzte Sprache um Kryptografische Anwendungen umzusetzen. Auch viele Verschlüsselungsbiblotheken von anderen Sprachen, sind letztendlich C Verbunde!
\vspace{2.5mm}

Obwohl Biblotheken viele arbeiten wie Hashing/Chiffrierung etc. abnehmen, kann man diese Operationen natürlich auch selber in 'plain' C nachschreiben. Dies wird im folgenden anhand des One time Pads gezeigt! 
\newpage



\begin{verbatim}
#include<stdio.h>
#include<string.h>
#include<ctype.h>

main(int argc, char *argv[])
{
    //Jegliche Eingaben werden in Großbuchstaben convertiert 
    //und Leerzeilen werden entfernt.
    int i,j,len1,len2,numstr[100],numkey[100],numcipher[100];
    char str[100],key[100],cipher[100];
    printf("Bitte geben Sie den zu verschlüsselnden Text ein\n");
    gets(str);
    for(i=0,j=0;i<strlen(str);i++) {
        if(str[i]!=' ') {
             str[j]=toupper(str[i]);   //toupper ist eine C interne Funktion
             j++;                      //die hier anhand einer For-Schleife
        }                              //die Eingaben in Großbuchstaben umschreibt
    }
    str[j]='\0';
    //Erhalt des Klartextes (nummerisch)
    for(i=0;i<strlen(str);i++) {
       numstr[i]=str[i]-'A';    
    }   
    printf("Bitte einen Zufälligen Text eingeben(Länge beliebig)\n");
    gets(key);
    for(i=0,j=0;i<strlen(key);i++) {
        if(key[i]!=' ') {
            key[j]=toupper(key[i]);   
            j++;
        }
    }
    key[j]='\0';
    //Erhalt des OTP bzw. Key
    for(i=0;i<strlen(key);i++) {
        numkey[i]=key[i]-'A';    
    }  

    for(i=0;i<strlen(str);i++) {
        numcipher[i]=numstr[i]+numkey[i];
    }
   
    for(i=0;i<strlen(str);i++) {
        if(numcipher[i]>25) {
           numcipher[i]=numcipher[i]-26;
        }
    }
    printf("Der One Time Pad Ciphertext ist\n");
    for(i=0;i<strlen(str);i++) {
        printf("%c",(numcipher[i]+'A')); 
    }
    printf("\n");

}

\end{verbatim}
\dots\\
Durch benutzen von 'gets()' setzt man das Programm ein recht hohes Risiko zu einem Buffer Overflow aus! Deshalb gilt die ungeschriebene Regel ' Dont write your own krypto'.
Bei Ausführung des Programmes zeigt sich folgendes:
\begin{figure}[h]

\includegraphics[scale=0.41]{otp.png}     
\end{figure}
Folgendes Beispiel zeigt ein Buffer Overflow.\\
\begin{verbatim}
#include<stdio.h> //Import von Librarys
#include<stdlib.h>
int main()
{
	//Speicher und Variablen Zuweisung
	char *place;
	char *systemcommand;
	place=(char *)malloc(10);
	systemcommand=(char *)malloc(90);
	//Gibt Speicheradressen Informationen an Bneutzer aus
	printf("Speicher Adresse von place ist : %d\n", place);
	printf("Speicher von systemcommand ist: %d\n", systemcommand);
	printf("Der Platz im Speicher zwischen place und systemcommand beträgt : %d\n", systemcommand-place);
	// Frägt wie viele Einwohner Albstadt hat
	printf("Wie viel Einwohner hat Albstadt");
	gets(place);
	// Printet Anwort für den user
	printf("Albstadt hat genau so viele Einwohner: %s\n", place);
	printf("Hello world");
	// Führt befehl gespeichert in systemcommand aus 
	system(systemcommand);
	
	
	return 0;                                                                                                                                                                             
}                                                                                                                                                                                             

\end{verbatim}

\newpage
\subsection{Biblotheken}
Als C 1976 erschien, war die Notwendigkeit von kryptographischen Verfahren und deren Implementierung noch lange nicht so hoch wie heute. Daher gab es anfangs auch wenige Bibliotheken speziell im Krypto-Bereich! Inzwischen hat C jedoch  eine breite Auswahl an Bibliotheken für kryptographische Verfahren die heute noch regelmäßig Updates bekommen.\\

\vspace{2mm}
\textbf{OpenSSL}: Die wohl bekannteste und meist genutzte Biblothek für Kryptografie. Nahezu alle HTTPS Websites nutzen diese Biblothek.\\
\dots\\
Um OpenSSL für C Code zu verwenden sollten folgende Header eingebunden werden.
\begin{verbatim}
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/rsa.h>
#include <openssl/x509.h>
\end{verbatim}
Je nach Verwendung müssen nun die notwendigen Initialisierungen durchgeführt werden. Dies könnte man anhand folgender Funktion umsetzen:
\begin{verbatim}
void init_ssl() {
     SSL_library_init(); 
     SSL_load_error_strings();
     ....
}
\end{verbatim}
Folgender Funktionsauschnitt generiert beispielweise einen RSA Key:
\begin{verbatim}
RSA *rsa;
rsa = RSA_new();
//RSA_generate_key_ex(r, bits, bn, NULL);

RSA_generate_key_ex(
	r,  // Zeiger auf RSA Struktur 
	bits, // Anzahl der bits für den Schlüssel zB. 2048
	bn,   // Zugeteilter Exponent  
	NULL, // Callback 
);

\end{verbatim}
Hier wird anschaulich lediglich ein einzelner Key generiert! Ein vollständiges Programm müsste zudem den Public und Private Key noch zwischenspeichern.

\newpage
Auch ist es möglich OpenSSl Kommandos die eigentlich in einer Shell ausgeführt werden in C Code zu implementieren.
Folgendes Kommando Generiert einen Private Key und ein Zertifikat.\\

\textbf{openssl req -out geekflare.csr -newkey rsa:2048 -nodes -keyout geekflare.key}

In einem C Programm eingebunden:
\begin{verbatim}
int main () {
   char c[50]; 
   strcpy( c, "openssl req -out geekflate.csr -newkey rsa:2084 ...." );
   system(c);
   return 0;
} 
\end{verbatim}
Diese Umsetzung von OpenSSL in C ist jedoch nur für kleinere Anwendungen\\ gebräuchlich!\\
\\
\textbf{Cryptlib}:
Bietet ein High-Level Interface zur einfachen Implementierung von Sicherheits-
funktionen. Sie ist komplett in C geschrieben, kann und wird aber auch in JAVA, C++ und weiteren Sprachen verwendet. Cryptlib umfasst unter anderem SSL/TLS, OpenPGP, MIME und viele weitere Protokolle und Standarts. Auch Krypto-Algorithmen wie AES,DES, RSA oder SHA-1/2 sind vertreten. Für die Verwendung in C Code sind 
folgende Header zu verwenden:
\begin{verbatim}
#include "cryptlib.h"
\end{verbatim}
Initialisierungen:
\begin{verbatim}
using cryptlib;
crypt.Init();
...
crypt.End();
\end{verbatim}
Hier wird nun eine Anwendung mit Sha realisiert:
\begin{verbatim}
Encrypt:
var cryptLib = require(’cryptlib’),
iv = cryptLib.generateRandomIV(16), //16 bytes = 128 bit
key = cryptLib.getHashSha256(’my secret key’, 32), //32 bytes = 256 bits
encryptedText = cryptLib.encrypt(’This is the text to be encrypted’, key, iv);
Decrypt:
var cryptLib = require(’cryptlib’),
iv = ’iv vector used for encryption’,
key = cryptLib.getHashSha256(’my secret key’, 32), //32 bytes = 256 bits
originalText = cryptLib.decrypt(’M2rfrn9DqNHJe3Hev9nMxKKgIHoqUsc7FJM+tBGxIrl3Wk9UeKIQ
\end{verbatim}
\dots
\newpage
Weitere Relevante Krypto Biblotheken sind:
\begin{itemize}
\item libsodium\\
asdasdasd \dots
\item LibreSSL
\item Libgcrypt
\item wolfCrypt
\item \dots
\end{itemize}

Es existieren mehr als 20 aktiv geführte Krypto Biblotheken in C. Dazu kommen etliche Github Repos die Krypto Anwendungen realisieren.\\
Nimmt man dies alles zusammen stellt man fest das C nach wie vor die meist genutze Sprache für Krypotgrafie ist!\\
\dots
\newpage
\section{C++}
C++ ist sehr nah an C aufgebaut und kann als direkter Nachfolger der Sprache bezeichnet werden. Aus heutiger Sicht, bzw. im Vergleich zu modernen Sprachen ist  auch sie als 'Low level' Programmiersprache einzuordnen. Funktionen wie freie Speicherverwaltung seitens des Programmierers oder arbeiten mit Zeigern sind vorhanden und teilweise ähnlich wie in C implementiert. Grundsätzlich weisen die beiden Sprachen eine recht hohe Ähnlichkeit auf, die sich jedoch größtenteils in Form der Notation bzw. Syntax äußert! Weitere Gemeinsamkeiten sind die allgemeine Code Struktur sowie Schlüsselwörter und Operatoren. Auch das Speichermodell ist orientiert an C, sehr nahe an der Hardware aufgebaut.\\
Denoch bestehen grundlegende Unterschiede zwischen beiden Sprachen!\\
So ist in C++ Objektorientierte Programmierung möglich. Dies lässt sich zwar in C anhand von 'structs' nachmodellieren, jedoch ist durch die Einführung der Klasse in C++ ein deutlich höheres Abstractionsniveau möglich!\\
Würde man in C beispielweise eine Matrix implementieren, so müsste man mehrer arrays anlegen und zwischen diesen Relationen herstellen. In C++ lässt sich dies wesentlich einfacher in Form der Klasse Matrix umsetzen.\\
Weitere Vorteile stellen Funktionen wie Excpeption Handling(Ausnahmebehandlung) oder Vererbung dar. Diese sind insbesondere auch für die Erstellung  Krypotgrafischer Anwendungen von Vorteil.\\
\vspace{1mm}\\
\subsection{Sicherheit}
Durch die Nähe zu C gelten nahezu alle Sichersrelevanten Schwachstellen auch in C++. Hängende Zeiger und Buffer Overflows sind genauso ein Problem wie Race conditions. Dennoch bietet C++ durch die Objektorientierung mehr Sicherheit. So können Variablen besser versteckt bzw. geschütz werden durch Abkapselung in Klassen!\\
Festhalten kann man das C++ durch einige Verbesserungen der Code Sicherheit durchaus eine bessere Eignung für Krypo-Anwendungen aufweißt. Dies zeigt sich auch in der Anzahl der realisierten Konzepte in diesem Bereich!\\
Viele bekannte Blockchain Projekte wie Bitcoin, Ethereum und Ripple sind in C++ verfasst.
\newpage
\subsection{Bibliotheken}
Auch C++ wurde bei Veröffentlichung 1985 nicht unbedingt für Kryptografische Zwecke entwickelt. Die Standart Biblothek enthält zwar mehr als in C, Funktionen die für Kryptografische Zwecke nützlich sind, denoch ist man bei größeren Krypto-Anwendungen auf neuere externe Biblotheken angewiesen! Davon gibt es heutzutage allerdings eine Vielzahl!\\
Hinzu kommt das nahezu alle C Biblotheken bzw. Header auch in C++ verwendbar sind. Diese müssen jedoch speziell deklariert werden!\\ 
Möchte man beispielweise aus C eine Standartbiblothek in C++ verwenden, muss man lediglich die '.h' Endung entfernen und ein 'c' prefix hinzufügen.\\ So wird aus: \begin{verbatim}
#include <stdio.h>       #include <cstdio>
\end{verbatim}
Will man andere Header verwenden die nicht teil der Standartbiblothek sind so geht das wie folgt:
\begin{verbatim}
extern "C"
{
    #include "weitere_header.h"
}                                                                                          \end{verbatim}
Viele C Biblotheken werden inzwischen durch C++ ergänzt bzw. weitergeführt. So ist \textbf{OpenSSL} in beiden Sprachen verwendbar und gebräuchlich!\\
Für \textbf{cryptlib} gilt das gleiche!\\
\vspace{1mm}\\
\textbf{Crypto++}:\\ Erstmals Veröffentlicht 1995 von Wei Dai. Seit 2015 arbeitet the Crypto++ Project daran weiter.\\
\vspace{1mm}\\
\textbf{Libtomcrypt}:\\
Bietet ähnliche Protokolle und Algorithmen wie OpenSLL. Jedoch deutlich einfacher gehalten. Wird auch als 'lighweight openssl' bezeichnet!\\Libtomcrypt besitz eine Public Domain licence!
\newpage
\textbf{Botan}:\\ 
Die wahrscheinlich wichtigste und Größte Krypto-Biblothek in C++!\\ Vom BSI evaluiert und für den Einsatz in Sicherheitsprodukten geeignet, klassifiziert. Bis heute regelmäßig durch das BSI geprüft.\\

Zu Beginn wird ein LibraryInitializer-Objekt erstellt. Mit diesem werden verschieden in
terne Strukturen auf und abgebaut.
\begin{verbatim}
 #include <botan/botan.h>
int main()
{
	LibraryInitializer init;
	return 0;
}
S2K* s2k = get_s2k("PBKDF2(SHA-256)");
s2k->set_iterations(4096);
s2k->new_random_salt(8);
SecureVector<byte> the_salt = s2k->current_salt();
SymmetricKey master_key = s2k->derive_key(48, passphrase);
KDF* kdf = get_kdf("KDF2(SHA-256)");
SymmetricKey key = kdf->derive_key(32, master_key, "cipher key");
SymmetricKey mac_key = kdf->derive_key(32, masterkey, "hmac key");
InitializationVector iv = kdf->derive_key(16, masterkey, "cipher iv");
Pipe pipe(new Fork(
	new Chain(
		get_cipher("Serpent/CBC/PKCS7", key, iv, ENCRYPTION),
			  new DataSink_Stream(outfile)
	),
	new MAC_Filter("HMAC(SHA-256)", mac_key)
)
);
outfile.write((const char*)the_salt.ptr(), the_salt.size());
pipe.start_msg();
infile >> pipe;
pipe.end_msg();
SecureVector<byte> hmac = pipe.read_all(1);
outfile.write((const char*)hmac.ptr(), hmac.size());
\end{verbatim}
Botan....
\newpage
\section{JAVA}
JAVA ist eine 'High level' Objektorientierte Sprache die nach wie vor sehr Verbreitet ist! Zählt man die Anzahl der Geräte auf denen JAVA läuft so stellt man fest das es  derzeit mitsamt Python die meist genutze Programmiersprache ist! Egal ob für Banking, Big Data oder Android. JAVA ist wie kaum eine andere Sprache in nahezu allen Anwendungsbereichen zu finden! Ein Grund dafür ist die hohe Plattformunabhängigkeit!\\
Java Programme werden zuerst in neutralen Bytecode übersetzt. Dieser wird dann von der
virtuellen Java Maschine (JVM) ausgeführt. Durch das ausführen in dieser virtuellen Umgebung, kann das Programm auf jedem System mit der Java Runtime Environment (JRE)
ausgeführt werden. Durch das verwenden von Bytecode erziehlt JAVA teilweise ähnliche Performance wie 'Low Level' Sprachen.\\
Um JAVA zu nutzen sollte das JAVA Runtime Environment(JDK) installiert sein. Dieses enthählt das JRE mitsamt Kompiler(javac), interpreter sowie die meisten Standart Packete!




\subsection{Sicherheit}
Java kennt keine Zeiger und Pufferüberläufe. Das macht es in gewissen Bereichen deutlich robuster.  Ebenso verfügt Java über Tools zur Laufzeitanalyse. So werden
Datentypen nicht nur beim Kompilieren geprüft, sondern auch während der Laufzeit.\\
Programmierfehler führen zwar auch hier zu unerwünschten Ergebnissen, hinterlassen aber weniger sicherheitskritische Lücken.\\Dennoch, 2019 führte die National Vulnerability Database (NVD) 56 Sicherheitsrelevante Schwachstellen auf, in denen 12 als kritisch eingestuft wurden.\\
\dots\\
Des weiteren bietet JAVA einige Security APIs an, die es Programmen erlaubt Sicherheitsoperationen durchzuführen!\\
Eine davon ist der \textbf{JAVA Security Manager}. Dieser ist eine integrierte Infrastruktur welche es ermöglicht Sicherheitsrelevante Regelwerke für Anwendungen zu implementieren. Anhand diesen können Operationen auf deren Sicherheit überprüft werden und gegebenenfalls durch Exceptions gestoppt werden!
\newpage
\subsection{Biblotheken}
Java nutzt statt freien Bibliotheken die Java-Cryptography-API (JCA), die in der Java-
Cryptography-Extension (JCE) implementiert ist.
Anfangs waren Java selbst und die JCE getrennt, da die USA sehr strenge Exportvorschriften
im Bereich kryptographischer Software hatten. So konnte in den USA die JCE geladen und
verwendet werden, wohingegen andere Länder mit eigenen oder deutlich schwächeren Algorithmen arbeiten mussten.
Mittlerweile ist die JCE überall verfügbar und befindet sich in den Packages \textbf{java.security} und \textbf{javax.crypto}.\\
Die JCE bietet folgende Funktionalitäten:\\
\begin{itemize}
 \item Cipher:\\
 Symmetrische Asymmetrische Verfahren zum Verschlüsseln
 \item Key-Management:\\ KeyGenerator, KeyAgreement und SecretKeyFactory
 \item Message Authentication Codes:\\
 Berechnung der Authentifizierung für Kommunikationen
 \item Sichere Objekte und Digitale Signaturen.
\end{itemize}
Im folgenden wird ein DES Schlüssel generiert und eine Nachricht chiffriert.
\begin{verbatim}
byte[] message = "Hallo Albstadt".getBytes();

KeyGenerator keygenerator = KeyGenerator.getInstance("DES");
SecretKey desKey = keygenerator.generateKey();

//Es wird DES mit dem Betriebsmodi ECB verwendet!
Cipher desCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
// Initialize the cipher for encryption
desCipher.init(Cipher.ENCRYPT_MODE, desKey);
// Encrypt message and return byte[]
encryptedMessage = desCipher.doFinal(message);
\end{verbatim}

\end{document}



